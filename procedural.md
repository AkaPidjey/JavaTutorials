[Java Tutorials](README.md)

# ProceduralJava
+ [Сколько ключевых слов зарезервировано языком, что это за слова, какие из них не используются?](#Сколько-ключевых-слов-зарезервировано-языком-что-это-за-слова-какие-из-них-не-используются)
+ [Из каких символов может состоять имя переменной (корректный идентификатор)?](#Из-каких-символов-может-состоять-имя-переменной-корректный-идентификатор)
+ [Какие примитивные типы данных есть в Java?](#Какие-примитивные-типы-данных-есть-в-Java)
+ [Что такое char?](#Что-такое-char)
+ [Сколько памяти занимает boolean?](#Сколько-памяти-занимает-boolean)
+ [Что такое классы-обертки (Wrapper Class)?](#Что-такое-классы-обертки-Wrapper-Class)
+ [Что такое автоупаковка и автораспаковка?](#Что-такое-автоупаковка-и-автораспаковка)
+ [Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?](#Что-такое-явное-и-неявное-приведение-типов-В-каких-случаях-в-java-нужно-использовать-явное-приведение) 

+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)
+ [к оглавлению](#ProceduralJava)


## Сколько ключевых слов зарезервировано языком, что это за слова, какие из них не используются?
50, два из них не используются: const, goto;

Для запоминания это:
+ Примитивы (byte, short, int, long, char, float, double, boolean)
+ Циклы и ветвления (if, else, switch, case, default, while, do, break, continue, for)
+ Исключения (try, catch, finally, throw, throws)
+ Области видимости (private, protected, public)
+ Объявление \ Импорт (import, package, class, interface, extends, implements, static, final, void, abstract, native)
+ Создание \ Возврат \ Вызов (new, return, this, super)
+ Многопоточность (synchronized, volatile)
+ instanceof, enum, assert, transient, strictfp, const, goto

http://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html

+ [к оглавлению](#ProceduralJava)

## Из каких символов может состоять имя переменной (корректный идентификатор)?
Имя или идентификатор переменной — это последовательность из строчных и заглавных латинских букв, цифр, а также символов «$» и «_». Имя переменной может начинаться с любого из перечисленных символов, кроме цифры.

Технически возможно начать имя переменной также с «$» или «_», однако это запрещено соглашением по оформлению кода в Java (Java Code Conventions). Кроме того, символ доллара «$», по соглашению, никогда не используется вообще. В соответствии с соглашением имя переменной должно начинаться именно с маленькой буквы (с заглавной буквы начинаются имена классов). Пробелы при именовании переменных не допускаются.

+ [к оглавлению](#ProceduralJava)

## Какие примитивные типы данных есть в Java?
__Вещественные, целочисленные, логические, строковые__

Примитивные:
+ byte (целые числа, 1 байт, [-128, 127])
+ short (целые числа, 2 байта, [-32768, 32767])
+ int (целые числа, 4 байта, [-2147483648, 2147483647])
+ long (целые числа, 8 байт, [-9223372036854775808,9223372036854775807])
+ float (вещественные числа, 4 байта)
+ double (вещественные числа, 8 байт)
+ char (символ Unicode, 2 байта, [0, 65536])
+ boolean (значение истина/ложь, используется int, зависит от JVM)

Ссылочные. В ссылочные типы входят все классы, интерфейсы, массивы.

http://stackoverflow.com/questions/383551/what-is-the-size-of-a-boolean-variable-in-java
boolean type: http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.4
boolean — боремся за Java память… https://habrahabr.ru/post/76481/

+ [к оглавлению](#ProceduralJava)

## Что такое char?
16-разрядное беззнаковое целое, представляющее собой символ UTF-16 (буквы и цифры)

+ [к оглавлению](#ProceduralJava)

## Сколько памяти занимает boolean?
Зависит от реализации JVM
В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 4 байта (32 бита), как и тип int. Однако, в определенных версия JVM имеются реализации, где в массиве boolean каждое значение занимает по 1-му биту.
Также есть библиотеки для уменьшения размера boolean: BitSet и OpenBitSet (от Apache).
Тип boolean прекрасно определяется множеством своих допустимых значений. Математически оно ограничивает минимальный размер значения одним битом.

Но использовать именно один бит (и ни битом более) эффективно далеко не всегда, поскольку на популярных архитектурах нельзя адресовать отдельные биты. А потому значения отдельных boolean'ов нельзя быстро сохранить в отдельные биты оперативной памяти — необходимо использовать комбинацию побитовых операций, что почти наверняка будет медленнее, чем запись целого отдельного регистра в оперативную память (размер которого может быть различным на разных платформах!).

Но при этом, к примеру, я вполне себе представляю, как на x86 компилятор может использовать в нативном коде в качестве какого-нибудь конкретного boolean-значения один бит регистра флагов, при условии, что это значение никогда не попадает в оперативную память (отдельно от других). Поэтому любые ограничения на размер более одного бита тоже могут потенциально мешать.

И эта свобода представления позволяет авторам виртуальных машин Java использовать любые реализации, которые они считают наиболее эффективными в каждом конкретном контексте. Как видно из примеров выше, любые ограничения будут только мешать.

+ [к оглавлению](#ProceduralJava)

## Что такое классы-обертки (Wrapper Class)?
Обертка — это специальный класс, который хранит внутри себя значение примитива.
Нужны для реализации дженериков.
Популярные методы:
+ Double.parseDouble(a);//пожалуй, самый популярный метод перевод из строки в целочисленный или дробный тип
+ System.out.println(Integer.MAX_VALUE);//константа максимального значения
+ System.out.println(Integer.bitCount(78));// в двоичном виде
+ System.out.println(Float.valueOf("80"));//возвращает целочисленный объект, содержащий значение указанного типа
Хотелось бы еще рассмотреть создание Boolean переменной:
```java
public class BooleanExample {
    public static void main(String[] args){
        Boolean b1 = new Boolean(false);//false
        Boolean b2 = new Boolean("false");//false
        Boolean b3 = new Boolean(true);//true
        Boolean b4 = new Boolean("true");//true
        Boolean b5 = new Boolean("hi there");//false
    }
}
```
+ [к оглавлению](#ProceduralJava)

## Что такое автоупаковка и автораспаковка?
__Автоупаковка__ - присвоение классу обертки значения примитивного типа;
__Автораспаковка__ - присвоение переменной примитивного типа значение класса обертки.

Для присваивания ссылок-примитивов объектам их классов-оберток (и наоборот) не требуется ничего делать, все происходит автоматически.

__Автоупаковка__ - это механизм неявной инициализации объектов классов-оберток (`Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`, `Character`, `Boolean`) значениями соответствующих им исходных примитивных типов (`byte`, `short`, `int`...), без явного использования конструктора класса. 

+ Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора `=`), либо при передаче примитива в параметры метода (типа класса-обертки). 

+ Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и константы времени компиляции (литералы и `final`-примитивы). При этом литералы должны быть синтаксически корректными для инициализации переменной исходного примитивного типа.

+ Автоупаковка переменных примитивных типов требует точного соответствия типа исходного примитива типу класса-обертки. Например, попытка упаковать переменную типа `byte` в `Short`, без предварительного явного приведения `byte` в `short` вызовет ошибку компиляции.

+ Автоупаковка констант примитивных типов допускает более широкие границы соответствия. В этом случае компилятор способен предварительно осуществлять неявное расширение/сужение типа примитивов:
    1) неявное расширение/сужение исходного типа примитива до типа примитива соответствующего классу-обертке (для преобразования `int` в `Byte`, сначала компилятор самостоятельно неявно сужает `int` к `byte`)
    2) автоупаковку примитива в соответствующий класс-обертку. Однако, в этом случае существуют два дополнительных ограничения:
        a) присвоение примитива обертке может производится только оператором `=` (нельзя передать такой примитив в параметры метода без явного приведения типов)
        b) тип левого операнда не должен быть старше чем `Character`, тип правого не дожен старше, чем `int`: допустимо расширение/сужение `byte` в/из `short`, `byte` в/из `char`, `short` в/из `char` и только сужение `byte` из `int`, `short` из `int`, `char` из `int`. Все остальные варианты требуют явного приведения типов).

Дополнительной особенностью целочисленных классов-оберток, созданных автоупаковкой констант в диапазоне `-128 ... +127` я вляется то, что они кэшируются JVM. Поэтому такие обертки с одинаковыми значениями будут являться ссылками на один объект.

+ [к оглавлению](#ProceduralJava)

## Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?
__Неявное приведение__ – автоматическое расширение типа переменной от меньшего к большему.
__Явное приведение__ -  явное сужение от большего к меньшему. Необходимо явно указать сужаемый тип.
В случае с объектами мы можем делать неявное(автоматическое) приведение от наследника к родителю, но не наоборот, иначе получим ClassCastException.

Преобразование может быть неявным и явным (приведение типов). Неявное преобразование может выполняться если:
типы совместимы (например – оба целочисленные)
размер “принимающего” типа больше чем у того, который преобразуется (так называемое “преобразование с расширением”)
```java
int a = 123454;
double b =  a; //неявное преобразование - преобразование с расширением
int a = 123454;
double b =  a; //неявное преобразование - преобразование с расширением

Явное преобразование имеет вид переменная_нового_типа = (новый_тип) имя переменной;
int a;
byte b = (byte) a; //b будет остатком от деления a на диапазон byte, может быть потеря данных
int a;
byte b = (byte) a; //b будет остатком от деления a на диапазон byte, может быть потеря данных
```
Примеры:
```java
public static void typeConverterExample() {
        long a = 100L;
        double b = 300.0;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 400.0

        double c = 1000.05;
        long d = 1000;
        Object cd = c+d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Double value: 2000.05
    }

    public static void typeNarrowing() {
        int a0 = 64;
        int a = 257;
        int a2 = 126;
        int a3 = 129;
        byte b0 = (byte) a0;
        byte b = (byte) a;
        byte b2 = (byte) a2;
        byte b3 = (byte) a3;
        System.out.println(b0+ " " + b + " " + b2 + " " + b3); //64 1 126 -127

        double c = 56.9876;
        int d = (int) c;
        System.out.println(d); //56

        long e = 1000L;
        float f = (float) e;
        System.out.println(f); //1000.0
    }

public static void typeConverterExample() {
        long a = 100L;
        double b = 300.0;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 400.0
 
        double c = 1000.05;
        long d = 1000;
        Object cd = c+d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Double value: 2000.05
    }
 
    public static void typeNarrowing() {
        int a0 = 64;
        int a = 257;
        int a2 = 126;
        int a3 = 129;
        byte b0 = (byte) a0;
        byte b = (byte) a;
        byte b2 = (byte) a2;
        byte b3 = (byte) a3;
        System.out.println(b0+ " " + b + " " + b2 + " " + b3); //64 1 126 -127
 
        double c = 56.9876;
        int d = (int) c;
        System.out.println(d); //56
 
        long e = 1000L;
        float f = (float) e;
        System.out.println(f); //1000.0
    }
```
При повышении типа byte>short; short>int; int>long; float>double; char>int информация не потеряется. При сужении возможна потеря информации (см. пример выше byte = (byte) int).

При различных операциях может происходить повышение типов в порядке “усиления” к более информативному типу. Например складывая int и double получим тип double. Но есть и особенность, например сложив double (8 байт) и long (8 байт) Java оставит знаки после запятой (double), а не более “длинный” тип. Аналогичный пример с вещественной частью:
```java
  long a = 100L;
        double b = a;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 200.0

        float c = 100;
        long d = 1000;
        Object cd = c - d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Float value: -900.0

  long a = 100L;
        double b = a;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 200.0
 
        float c = 100;
        long d = 1000;
        Object cd = c - d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Float value: -900.0
```
Кратко можно записать такие правила:
+ byte, short, char в выражениях всегда повышаются до int
+ если в выражении участвует тип long – то именно к этому типу будет приведён результат
+ если в выражении участвует float – то результат приводится к float
+ если один из операндов имеет тип double – то к этому типу будет приведён весь результат
+ При выборе между длиной и возможностью сохранить дробную часть – будет выбрана дробная часть

+ [к оглавлению](#ProceduralJava)






## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ

#### [Название-->]( Ссылка )
#### [Название-->]( Ссылка )
#### [Название-->]( Ссылка )
#### [Название-->]( Ссылка )
#### [Название-->]( Ссылка )
#### [Название-->]( Ссылка )
#### [Название-->]( Ссылка )

+ [к оглавлению](#ProceduralJava)
