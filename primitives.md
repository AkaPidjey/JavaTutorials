[Java Tutorials](README.md)

# Примитивные типы
## Примитивные типы / Переменные / Операторы / Циклы / Массивы
+ [Сколько ключевых слов зарезервировано языком, что это за слова, какие из них не используются?](#Сколько-ключевых-слов-зарезервировано-языком-что-это-за-слова-какие-из-них-не-используются)
+ [Из каких символов может состоять имя переменной (корректный идентификатор)?](#Из-каких-символов-может-состоять-имя-переменной-корректный-идентификатор)
+ [Какие примитивные типы вы знаете?](#Какие-примитивные-типы-вы-знаете)
+ [Какие логические операции и операторы вы знаете?](#Какие-логические-операции-и-операторы-вы-знаете)
+ [Что такое тернарный оператор выбора?](#Что-такое-тернарный-оператор-выбора)
+ [Какие побитовые операции вы знаете?](#Какие-побитовые-операции-вы-знаете)
+ [Какие унарные и бинарные арифметические операции вы знаете?](#Какие-унарные-и-бинарные-арифметические-операции-вы-знаете)
+ [Что вы знаете о преобразовании примитивных типов данных, есть ли потеря данных, можно ли преобразовать логический тип?](#Что-вы-знаете-о-преобразовании-примитивных-типов-данных-есть-ли-потеря-данных-можно-ли-преобразовать-логический-тип)
+ [Что такое _autoboxing («автоупаковка»)_ в Java и каковы правила упаковки примитивных типов в классы-обертки?](#Что-такое-autoboxing-автоупаковка-в-java-и-каковы-правила-упаковки-примитивных-типов-в-классы-обертки)
+ [Какова роль и правила написания оператора выбора (switch)?](#Какова-роль-и-правила-написания-оператора-выбора-switch)
+ [Какие циклы вы знаете, в чем их отличия?](#Какие-циклы-вы-знаете-в-чем-их-отличия)
+ [Какие операторы используются для перехода к следующей итерации и немедленной остановки цикла?](#Какие-операторы-используются-для-перехода-к-следующей-итерации-и-немедленной-остановки-цикла)
+ [Размер типа `Boolean`?](#Размер-типа-Boolean)
+ [Классы обертки (Wrapper Class) для примитивных типов.](#Классы-обертки-Wrapper-Class-для-примитивных-типов)
+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)


## Сколько ключевых слов зарезервировано языком, что это за слова, какие из них не используются?
50, два из них не используются: const, goto;

Для запоминания это:
+ Примитивы (byte, short, int, long, char, float, double, boolean)
+ Циклы и ветвления (if, else, switch, case, default, while, do, break, continue, for)
+ Исключения (try, catch, finally, throw, throws)
+ Области видимости (private, protected, public)
+ Объявление \ Импорт (import, package, class, interface, extends, implements, static, final, void, abstract, native)
+ Создание \ Возврат \ Вызов (new, return, this, super)
+ Многопоточность (synchronized, volatile)
+ instanceof, enum, assert, transient, strictfp, const, goto

http://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html

[к оглавлению](#примитивные-типы)

## Из каких символов может состоять имя переменной (корректный идентификатор)?
Имя или идентификатор переменной — это последовательность из строчных и заглавных латинских букв, цифр, а также символов «$» и «_». Имя переменной может начинаться с любого из перечисленных символов, кроме цифры.

Технически возможно начать имя переменной также с «$» или «_», однако это запрещено соглашением по оформлению кода в Java (Java Code Conventions). Кроме того, символ доллара «$», по соглашению, никогда не используется вообще. В соответствии с соглашением имя переменной должно начинаться именно с маленькой буквы (с заглавной буквы начинаются имена классов). Пробелы при именовании переменных не допускаются.

[к оглавлению](#примитивные-типы)

## Какие примитивные типы вы знаете?
Примитивные:
+ byte (целые числа, 1 байт, [-128, 127])
+ short (целые числа, 2 байта, [-32768, 32767])
+ int (целые числа, 4 байта, [-2147483648, 2147483647])
+ long (целые числа, 8 байт, [-9223372036854775808,9223372036854775807])
+ float (вещественные числа, 4 байта)
+ double (вещественные числа, 8 байт)
+ char (символ Unicode, 2 байта, [0, 65536])
+ boolean (значение истина/ложь, используется int, зависит от JVM)

Ссылочные. В ссылочные типы входят все классы, интерфейсы, массивы.

http://stackoverflow.com/questions/383551/what-is-the-size-of-a-boolean-variable-in-java
boolean type: http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.4
boolean — боремся за Java память… https://habrahabr.ru/post/76481/

[к оглавлению](#примитивные-типы)

## Какие логические операции и операторы вы знаете?
+ `&`: Логическое _AND_ (И);
+ `&&`: Сокращённое _AND_;
+ `|`: Логическое _OR_ (ИЛИ);
+ `||`: Сокращённое _OR_;
+ `^`: Логическое _XOR_ (исключающее _OR_ (ИЛИ));
+ `!`: Логическое унарное _NOT_ (НЕ);
+ `&=`: _AND_ с присваиванием;
+ `|=`: _OR_ с присваиванием;
+ `^=`: _XOR_ с присваиванием;
+ `==`: Равно;
+ `!=`: Не равно;
+ `?:`: Тернарный (троичный) условный оператор.

[к оглавлению](#примитивные-типы)


## Что такое тернарный оператор выбора?
Тернарный условный оператор `?:` - оператор, которым можно заменить некоторые конструкции операторов `if-then-else`.

Выражение записывается в следующей форме:
>условие ? выражение1 : выражение2

Если `условие` выполняется, то вычисляется `выражение1` и его результат становится результатом выполнения всего оператора. Если же `условие` равно `false`, то вычисляется `выражение2` и его значение становится результатом работы оператора. Оба операнда `выражение1` и `выражение2` должны возвращать значение одинакового (или совместимого) типа.

[к оглавлению](#примитивные-типы)

## Какие побитовые операции вы знаете?
+ `~`: Побитовый унарный оператор NOT;
+ `&`: Побитовый AND;
+ `&=`: Побитовый AND с присваиванием;
+ `|`: Побитовый OR;
+ `|=`: Побитовый OR с присваиванием;
+ `^`: Побитовый исключающее XOR;
+ `^=`: Побитовый исключающее XOR с присваиванием;
+ `>>`: Сдвиг вправо (деление на 2 в степени сдвига);
+ `>>=`: Сдвиг вправо с присваиванием;
+ `>>>`: Сдвиг вправо без учёта знака;
+ `>>>=`: Сдвиг вправо без учёта знака с присваиванием;
+ `<<`: Сдвиг влево (умножение на 2 в степени сдвига);
+ `<<=`: Сдвиг влево с присваиванием.

[к оглавлению](#примитивные-типы)

## Какие унарные и бинарные арифметические операции вы знаете?
Унарные операции выполняются над одним операндом, бинарные – над двумя операндами, а также тернарные – выполняются над тремя операндами. Операндом является переменная или значение (например, число), участвующее в операции.

Пример унарных арифметических операций:
+ / ++ – постфиксный/префиксный инкремент, увеличивает значение целочисленной переменной на 1;
+ / — (двойной минус) – постфиксный/префиксный декремент, уменьшает значение целочисленной переменной на 1;
+ / + – оставляет знак числа;
+ / – – изменяет знак числа.
Слово постфиксный означает, что операция применится к операнду после вычисления всего выражения, в которое операнд входит. Аналогично префиксный означает, что операция применится до вычисления выражения.

Пример бинарных арифметических операций:
+ / + – сложение чисел или строк;
+ / –  – вычитание чисел;
+ / * – умножения чисел;
+ / / – деления чисел;
+ / % – вычисление остатка от деления чисел.
Операция вычисления остатка от деления применима как к целым числам, так и к вещественным.

[к оглавлению](#примитивные-типы)

## Что вы знаете о преобразовании примитивных типов данных, есть ли потеря данных, можно ли преобразовать логический тип?
Преобразование может быть неявным и явным (приведение типов). Неявное преобразование может выполняться если:
типы совместимы (например – оба целочисленные)
размер “принимающего” типа больше чем у того, который преобразуется (так называемое “преобразование с расширением”)
```java
int a = 123454;
double b =  a; //неявное преобразование - преобразование с расширением
int a = 123454;
double b =  a; //неявное преобразование - преобразование с расширением

Явное преобразование имеет вид переменная_нового_типа = (новый_тип) имя переменной;
int a;
byte b = (byte) a; //b будет остатком от деления a на диапазон byte, может быть потеря данных
int a;
byte b = (byte) a; //b будет остатком от деления a на диапазон byte, может быть потеря данных
```
Примеры:
```java
public static void typeConverterExample() {
        long a = 100L;
        double b = 300.0;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 400.0

        double c = 1000.05;
        long d = 1000;
        Object cd = c+d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Double value: 2000.05
    }

    public static void typeNarrowing() {
        int a0 = 64;
        int a = 257;
        int a2 = 126;
        int a3 = 129;
        byte b0 = (byte) a0;
        byte b = (byte) a;
        byte b2 = (byte) a2;
        byte b3 = (byte) a3;
        System.out.println(b0+ " " + b + " " + b2 + " " + b3); //64 1 126 -127

        double c = 56.9876;
        int d = (int) c;
        System.out.println(d); //56

        long e = 1000L;
        float f = (float) e;
        System.out.println(f); //1000.0
    }

public static void typeConverterExample() {
        long a = 100L;
        double b = 300.0;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 400.0
 
        double c = 1000.05;
        long d = 1000;
        Object cd = c+d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Double value: 2000.05
    }
 
    public static void typeNarrowing() {
        int a0 = 64;
        int a = 257;
        int a2 = 126;
        int a3 = 129;
        byte b0 = (byte) a0;
        byte b = (byte) a;
        byte b2 = (byte) a2;
        byte b3 = (byte) a3;
        System.out.println(b0+ " " + b + " " + b2 + " " + b3); //64 1 126 -127
 
        double c = 56.9876;
        int d = (int) c;
        System.out.println(d); //56
 
        long e = 1000L;
        float f = (float) e;
        System.out.println(f); //1000.0
    }
```
При повышении типа byte>short; short>int; int>long; float>double; char>int информация не потеряется. При сужении возможна потеря информации (см. пример выше byte = (byte) int).

При различных операциях может происходить повышение типов в порядке “усиления” к более информативному типу. Например складывая int и double получим тип double. Но есть и особенность, например сложив double (8 байт) и long (8 байт) Java оставит знаки после запятой (double), а не более “длинный” тип. Аналогичный пример с вещественной частью:
```java
  long a = 100L;
        double b = a;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 200.0

        float c = 100;
        long d = 1000;
        Object cd = c - d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Float value: -900.0

  long a = 100L;
        double b = a;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 200.0
 
        float c = 100;
        long d = 1000;
        Object cd = c - d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Float value: -900.0
```
Кратко можно записать такие правила:
+ byte, short, char в выражениях всегда повышаются до int
+ если в выражении участвует тип long – то именно к этому типу будет приведён результат
+ если в выражении участвует float – то результат приводится к float
+ если один из операндов имеет тип double – то к этому типу будет приведён весь результат
+ При выборе между длиной и возможностью сохранить дробную часть – будет выбрана дробная часть

[к оглавлению](#примитивные-типы)

## Что такое _autoboxing («автоупаковка»)_ в Java и каковы правила упаковки примитивных типов в классы-обертки?
__Автоупаковка__ - это механизм неявной инициализации объектов классов-оберток (`Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`, `Character`, `Boolean`) значениями соответствующих им исходных примитивных типов (`byte`, `short`, `int`...), без явного использования конструктора класса. 

+ Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора `=`), либо при передаче примитива в параметры метода (типа класса-обертки). 

+ Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и константы времени компиляции (литералы и `final`-примитивы). При этом литералы должны быть синтаксически корректными для инициализации переменной исходного примитивного типа.

+ Автоупаковка переменных примитивных типов требует точного соответствия типа исходного примитива типу класса-обертки. Например, попытка упаковать переменную типа `byte` в `Short`, без предварительного явного приведения `byte` в `short` вызовет ошибку компиляции.

+ Автоупаковка констант примитивных типов допускает более широкие границы соответствия. В этом случае компилятор способен предварительно осуществлять неявное расширение/сужение типа примитивов:
    1) неявное расширение/сужение исходного типа примитива до типа примитива соответствующего классу-обертке (для преобразования `int` в `Byte`, сначала компилятор самостоятельно неявно сужает `int` к `byte`)
    2) автоупаковку примитива в соответствующий класс-обертку. Однако, в этом случае существуют два дополнительных ограничения:
        a) присвоение примитива обертке может производится только оператором `=` (нельзя передать такой примитив в параметры метода без явного приведения типов)
        b) тип левого операнда не должен быть старше чем `Character`, тип правого не дожен старше, чем `int`: допустимо расширение/сужение `byte` в/из `short`, `byte` в/из `char`, `short` в/из `char` и только сужение `byte` из `int`, `short` из `int`, `char` из `int`. Все остальные варианты требуют явного приведения типов).

Дополнительной особенностью целочисленных классов-оберток, созданных автоупаковкой констант в диапазоне `-128 ... +127` я вляется то, что они кэшируются JVM. Поэтому такие обертки с одинаковыми значениями будут являться ссылками на один объект.

[к оглавлению](#примитивные-типы)

## Какова роль и правила написания оператора выбора (switch)?
Оператор switch сравнивает аргумент на равенство с предложенным значением.
```java
switch(ВыражениеДляСравнения) {
    case Совпадение1: 
	    команда;
		break;
	case Совпадение2: 
	    команда;
		break;
	case Совпадение3: 
	    команда;
		break;
	default: 
	    оператор;
	    break;
}
```
Обязательно необходимо ставить break; после завершения тело команды, иначе будет продолжаться выполнение ниже по строчкам.
Подробнее http://developer.alexanderklimov.ru/android/java/switch.php

[к оглавлению](#примитивные-типы)

## Какие циклы вы знаете, в чем их отличия?
В Java используются циклы for, while, do-while.
```java
while(условие) {
    // тело цикла
}
 
do {
    // тело цикла }
while(условие-логическое выражение)
 
for(инициализация; логическое выражение (условие); шаг (итерация)) {
    // тело цикла
}
 
for(Object object : objects) {
    // тело цикла 
}
```
do-while всегда выполнится хотя бы один раз, т.к. проверка идет после тела цикла.

[к оглавлению](#примитивные-типы)

## Какие операторы используются для перехода к следующей итерации и немедленной остановки цикла?
+ break; – выход из цикла (не затрагивает внешний цикл).
+ continue; – заканчивает выполнение кода в этом теле цикла. Переход к следующей итерации.
```java
for (int i=0; i < 3; i++) {
            for (int j = 0; j < 4; j++) {
                if (j == 2) {
                    System.out.println("#A# i: " + i + " j: " + j + " break (end j loop). Will not see #C#");
                    break;
                }
                if (j == 1) {
                    System.out.println("#B# i: " + i + " j: " + j + " continue (j++).Will not see #C#");
                    continue;
                }
                System.out.println("#C# i: " + i + " j: " + j);
            }
        }
#C# i: 0 j: 0
#B# i: 0 j: 1 continue (j++).Will not see #C#
#A# i: 0 j: 2 break (end j loop). Will not see #C#
#C# i: 1 j: 0
#B# i: 1 j: 1 continue (j++).Will not see #C#
#A# i: 1 j: 2 break (end j loop). Will not see #C#
#C# i: 2 j: 0
#B# i: 2 j: 1 continue (j++).Will not see #C#
#A# i: 2 j: 2 break (end j loop). Will not see #C#
```
[к оглавлению](#примитивные-типы)

## Размер типа Boolean?
В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 4 байта (32 бита), как и тип int. Однако, в определенных версия JVM имеются реализации, где в массиве boolean каждое значение занимает по 1-му биту.
Также есть библиотеки для уменьшения размера boolean: BitSet и OpenBitSet (от Apache).
Тип boolean прекрасно определяется множеством своих допустимых значений. Математически оно ограничивает минимальный размер значения одним битом.

Но использовать именно один бит (и ни битом более) эффективно далеко не всегда, поскольку на популярных архитектурах нельзя адресовать отдельные биты. А потому значения отдельных boolean'ов нельзя быстро сохранить в отдельные биты оперативной памяти — необходимо использовать комбинацию побитовых операций, что почти наверняка будет медленнее, чем запись целого отдельного регистра в оперативную память (размер которого может быть различным на разных платформах!).

Но при этом, к примеру, я вполне себе представляю, как на x86 компилятор может использовать в нативном коде в качестве какого-нибудь конкретного boolean-значения один бит регистра флагов, при условии, что это значение никогда не попадает в оперативную память (отдельно от других). Поэтому любые ограничения на размер более одного бита тоже могут потенциально мешать.

И эта свобода представления позволяет авторам виртуальных машин Java использовать любые реализации, которые они считают наиболее эффективными в каждом конкретном контексте. Как видно из примеров выше, любые ограничения будут только мешать.

[к оглавлению](#примитивные-типы)

## Классы обертки (Wrapper Class) для примитивных типов.
Популярные методы:
+ Double.parseDouble(a);//пожалуй, самый популярный метод перевод из строки в целочисленный или дробный тип
+ System.out.println(Integer.MAX_VALUE);//константа максимального значения
+ System.out.println(Integer.bitCount(78));// в двоичном виде
+ System.out.println(Float.valueOf("80"));//возвращает целочисленный объект, содержащий значение указанного типа
Хотелось бы еще рассмотреть создание Boolean переменной:
```java
public class BooleanExample {
    public static void main(String[] args){
        Boolean b1 = new Boolean(false);//false
        Boolean b2 = new Boolean("false");//false
        Boolean b3 = new Boolean(true);//true
        Boolean b4 = new Boolean("true");//true
        Boolean b5 = new Boolean("hi there");//false
    }
}
```
[к оглавлению](#примитивные-типы)

## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ
#### [Foreach java — подробное руководство-->](https://hr-vector.com/java/foreach)
#### [Название-->](Ссылка)
#### [Название-->](Ссылка)
#### [Название-->](Ссылка)
#### [Название-->](Ссылка)


[к оглавлению](#примитивные-типы)
