[Java Tutorials](README.md)

# Spring

## Spring Core
+ [Что такое Spring? Чем фреймворк отличается от библиотеки?](#Что-такое-Spring-Чем-фреймворк-отличается-от-библиотеки)
+ [Что такое бины?](#Что-такое-бины)
+ [Назовите способы создания бинов?](#Назовите-способы-создания-бинов)
+ [Виды бинов? Скоупы бинов? Какой по-умолчанию?](#Виды-бинов-Скоупы-бинов-Какой-по-умолчанию)
+ [Чем бин отличается от POJO-класса?](#Чем-бин-отличается-от-POJO-класса)
+ [Что такое Inversion of Control и как Spring реализует этот принцип?](#Что-такое-Inversion-of-Control-и-как-Spring-реализует-этот-принцип)
+ [Что такое контекст Spring и как его создать?](#Что-такое-контекст-Spring-и-как-его-создать)
+ [Как можно связать бины?](#Как-можно-связать-бины)
+ [@Autowired, где можно ставить и какие есть отличия?](#Autowired-где-можно-ставить-и-какие-есть-отличия)
+ [Опишите поведение аннотации @Autowired](#Опишите-поведение-аннотации-Autowired)
+ [Что такое Dependency Injection? Чем отличается от композиции?](#Что-такое-Dependency-Injection-Чем-отличается-от-композиции)
+ [Какие бины будут использоваться для настройки приложения?](#Какие-бины-будут-использоваться-для-настройки-приложения)
+ [Принципы работы Spring.](#принципы-работы-Spring)
+ [Жизненный цикл Бина.](#Жизненный-цикл-Бина)
+ [Основные паттерны Spring.](#Основные-паттерны-Spring)
+ [Рассказать про Singleton, как реализуется без Спринга?](#Рассказать-про-Singleton-как-реализуется-без-Спринга)


## Spring MVC
+ [Как получить данные из файла .property?](#Как-получить-данные-из-файла-property)
+ [Как запустить Спринг-приложение из-под сервера Tomcat?](#Как-запустить-Спринг-приложение-из-под-сервера-Tomcat)
+ [Что такое Artifacts?](#Что-такое-Artifacts)
+ [В чем отличие артефакта war от war exploded?](#В-чем-отличие-артефакта-war-от-war-exploded)
+ [Какая разница между аннотациями @Component, @Repository и @Service в Spring?](#Какая-разница-между-аннотациями-Component-Repository-и-Service-в-Spring)
+ [Как выглядит структура MVC-приложения?](#Как-выглядит-структура-MVC-приложения)
+ [Какая основная зависимость фреймворка Спринг? Почему во многих сборках она не указывается явно?](#Какая-основная-зависимость-фреймворка-Спринг-Почему-во-многих-сборках-она-не-указывается-явно)
+ ???[Чем контроллер отличается от сервлета?](#Чем-контроллер-отличается-от-сервлета)
+ ???[Как вернуть страницу в контроллере? Как вернуть данные?](#Как-вернуть-страницу-в-контроллере-Как-вернуть-данные)
+ [Как интегрировать Hibernate и Spring?](#Как-интегрировать-Hibernate-и-Spring)



## Spring Security




+ [к оглавлению](#spring)





# Spring Core

## Что такое Spring? Чем фреймворк отличается от библиотеки?
Spring Framework - представляет собой просто контейнер внедрения зависимостей, с несколькими удобными слоями (например: доступ к базе данных, прокси, аспектно-ориентированное программирование, RPC, веб-инфраструктура MVC). Это все позволяет вам быстрее и удобнее создавать Java-приложения.


«Фреймворк» отличается от понятия библиотеки тем, что библиотека может быть использована в программном продукте просто как набор подпрограмм близкой функциональности, не влияя на архитектуру программного продукта и не накладывая на неё никаких ограничений. В то время как «фреймворк» диктует правила построения архитектуры приложения, задавая на начальном этапе разработки поведение по умолчанию — «каркас», который нужно будет расширять и изменять, согласно указанным требованиям.

Также, в отличие от библиотеки, которая объединяет в себе набор близкой функциональности, — «фреймворк» может содержать в себе большое число разных по тематике библиотек.

Другим ключевым отличием «фреймворка» от библиотеки может быть инверсия управления: пользовательский код вызывает функции библиотеки (или классы) и получает управление после вызова. Во «фреймворке» пользовательский код может реализовывать конкретное поведение, встраиваемое в более общий — «абстрактный» код фреймворка. При этом «фреймворк» вызывает функции (классы) пользовательского кода.
+ [к оглавлению](#spring)


## Что такое бины?
Начнем срывать покровы с самых базовых понятий Spring. Бин (bean) — это не что иное, как самый обычный объект. Разница лишь в том, что бинами принято называть те объекты, которые управляются Spring-ом и живут внутри его DI-контейнера. Бином является почти все в Spring — сервисы, контроллеры, репозитории, по сути все приложение состоит из набора бинов. Их можно регистрировать, получать в качестве зависимостей, проксировать, мокать и т.п.
+ [к оглавлению](#spring)


## Назовите способы создания бинов?
__Существует 4 способа создания бинов:__
+ xml - старый способ, как преимущество - централизованная конфигурация контекста
+ аннотации - простота и удобство, как недостаток - децентрализованная конфигурация
+ Java конфигурация - пока лучший способ.
+ Groovy - заменит и java и xml, но пока он не достаточно хорош.

+ __XML__

Исторически конфигурирование контекста c использованием XML было первым методом конфигурирования, появившемся в Spring.
Конфигурирование с помощью XML заключается в создании xml файла (традиционно носящего названия вида «context.xml», «applicationContext.xml» и т.д.), описывающего Spring beans, процесс их создания и взаимосвязи между ними. 
Не использует аннотаций.
```java
    <bean id="coin" class="stas.paliutin.spring.CoinImpl">
        <constructor-arg type="java.util.Random">
            <bean class="java.util.Random"/>
        </constructor-arg>
    </bean>
```
Вначале мы определили бин «coin», передав ему в конструктор внутренний анонимный бин, созданный из java.util.Random. Связывание было проведено по типу аргумента, а передаваемый в конструктор бин был определён на месте.

+ __Аннотации__
```java
ApplicationContext context = 
	new AnnotationConfigApplicationContext("where.is.entities");
```
Сначала мы создаем объект контекста, и в конструкторе указываем ему имя пакета, которое надо сканировать на наличие в нем бинов.
Второй способ сделать это, через указание аннотации @ComponentScan(“...”) вместе с @Configuration. 
```java
@Configuration
@ComponentScan("where.is.entities")
public class WebConfig {
    private static ApplicationContext applicationContext;

    public WebConfig(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
```
То-есть, спринг пройдется по этому пакету и попробует найти такие классы, которые отмечены специальными аннотациями, дающими спрингу понять, что это — бин. После чего он создает объекты этих классов и помещает их себе в контекст.
Сами бины для сканирования помечаются через аннотации @Component и все остальные аннотации, которые наследуются от этой. Например, @Controller, @RestController, @Service, @Repository и другие.
Имя бина будет именем класса с маленькой буквы. Либо можно специально указать в () аннотации.
```java
@Component(“myBean”);
```
Суть: Пишете ваши классы, отмечаете их нужными аннотациями, и указываете спрингу пакет с вашими классами, по которому он идет, ищет аннотации и создает объекты таких классов.

+ __JAVA конфигурация__

Чтобы создать класс с конфигурацией на основе Java-кода, нужно аннотировать его с помощью
@Configuration.
Spring вызывает в конфигурационных классах методы с аннотацией @Bean. Объекты, возвращённые этими методами, регистрируются как Spring бины. Названия бинов соответствуют названиям методов, которые их порождают.
```java
    @Bean
    public Cat cat() {
        return new Cat(“Meoy”);
    }
```
Java конфигурация выглядит наилучшим образом, если сравнивать её достоинства и недостатки. Это и централизованность как в xml; и безопасность типов; и простой рефакторинг; и отсутствия spring специфичных вещей в коде; и возможность выполнения каких-либо действий на этапе конфигурации. К недостаткам, пожалуй, относится необходимость ручного создания бинов и необходимость пересборки для переконфигурации приложения.

Важно и название класса конфигурации: несмотря на искушение назвать конфигурационный класс Context, делать этого не следует. Дело в том, что Spring создаст бин и из этого класса, а в качестве имени использует имя класса. А имя «Context» уже занято самим Spring.

+ __Groovy__

Поддержка Groovy скриптов и специального beans DSL появилась в 4 версии Spring как попытка сделать конфигурацию вообще без недостатков. Groovy конфигурация должна объединить в себе достоинства XML конфигурации и Java конфигурации, оставаясь дружественной к аннотациям.
К достоинствам groovy конфигурации можно отнести всё хорошее, что есть в XML и Java подходах: централизованное описание приложения, которое может хранится отдельно от кода, позволяя менять структуру приложения без пересборки (а в перспективе без перезапуска); использование стороннего кода в качестве Spring beans; возможность сохранить код чистым от Spring аннотаций; безопасность типов и простота рефакторинга; выполнение кода на этапе конфигурирования. Однако поддержка groovy конфигурации ещё недостаточно доработана и не все возможности, достижимые с помощью xml/java, доступны с groovy.
+ [к оглавлению](#spring)


## Виды бинов? Скоупы бинов? Какой по-умолчанию?
Бины можно классифицировать по функциональной роли и по “Скоупу” (во многих источниках “области видимости”)
По функциональному назначение бины могут аннотироваться разным способом (Стереотипы):
+ __@Component__ - бин общего назначения
+ __@Controller__ - контроллер в архитектуре MVC
+ __@Service__ - сервисный слой
+ __@Repository__ - дао слой

__Scope бинов__
Область видимости указывается с помощью аннотации @Scope на @Bean методах или .
+ __singleton__ 
Определяет один единственный бин для каждого контейнера Spring IoC (используется по умолчанию).
+ __prototype__
Позволяет иметь любое количество экземпляров бина.
+ __request__
Создаётся один экземпляр бина на каждый HTTP запрос. Касается исключительно ApplicationContext.
+ __session__
Создаётся один экземпляр бина на каждую HTTP сессию. Касается исключительно ApplicationContext.
+ __global-session__
Создаётся один экземпляр бина на каждую глобальную HTTP сессию. Касается исключительно ApplicationContext.

По умолчанию бину присваивается Скоуп singleton.
+ [к оглавлению](#spring)



## Чем бин отличается от POJO-класса?
__POJO (англ. Plain Old Java Object)__ — «старый добрый Java-объект», простой Java-объект, не унаследованный от какого-то специфического объекта и не реализующий никаких служебных интерфейсов сверх тех, которые нужны для бизнес-модели.

Все JavaBeans - это POJO, но не все POJO - это JavaBeans.

JavaBean - это объект Java, который удовлетворяет определенным соглашениям о программном обеспечении:
+ 1 - класс JavaBean должен реализовывать либо Serializable, либо Externalizable;
+ 2 - класс JavaBean должен иметь открытый конструктор no-arg;
+ 3 - все свойства JavaBean должны иметь общедоступные методы setter и getter (в зависимости от ситуации);
+ 4 - все переменные экземпляра JavaBean должны быть частными.
+ [к оглавлению](#spring)

## Что такое Inversion of Control и как Spring реализует этот принцип?
__Inversion of Control (инверсия управления)__ — это некий абстрактный принцип, набор рекомендаций для написания слабо связанного кода. Суть которого в том, что каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов.
__Как Spring реализует этот принцип?__
Центральной частью Spring является контейнер Inversion of Control, который предоставляет средства конфигурирования и управления объектами Java с помощью рефлексии. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой и т.д.

Объекты, создаваемые контейнером, также называются управляемыми объектами (beans). Обычно, конфигурирование контейнера, осуществляется путём внедрения аннотаций (начиная с 5 версии J2SE), но также, есть возможность, по старинке, загрузить XML-файлы, содержащие определение bean’ов и предоставляющие информацию, необходимую для создания bean’ов.

#### [Концепция Inversion of Control и основы Spring-->]( http://javatutor.net/articles/spring-basic-and-inversion-of-control )
#### [Инверсии зависимостей управления впрыском-->]( https://habr.com/ru/post/321344/ )
#### [Spring для домохозяек. Inversion of Control на практике.-->]( https://nikcode.blogspot.com/2011/09/spring-inversion-of-control.html )
+ [к оглавлению](#spring)

## Что такое контекст Spring и как его создать?
Контекст (а у него есть даже интерфейс — org.springframework.context.ApplicationContext) — это некоторое окружение, в котором работает приложение на Spring Framework. Страшные аббревиатуры DI, IoC — это всё про него. Собственно, контекст создаёт и хранит экземпляры классов вашего приложения, определяет их зависимости друг с другом и автоматически их задаёт.

Безусловно, для того чтобы Spring создал контекст с экземплярами классов, ему нужно предоставить дополнительную информацию — мета-данные, из каких классов/объектов состоит ваше приложение, как они создаются, какие у них есть зависимости и т. д.

Итого: Spring Context + мета-данные = работающее приложение.

Где найти контекст?
Контекст является ключевой функциональностью Spring и лежит в maven-зависимости spring-context (на момент написания — org.springframework:spring-context:5.1.4.RELEASE). Обычно эта зависимость является транзитивной для остальных проектов Spring. И если вы, например, подключаете spring-boot-starter, то она подключится автоматически, и не нужно думать про то, где её взять.

Но если вы хотите попробовать "голый" Spring, т. е. только ту часть, которая называется IoC-контейнер, то достаточно подключить лишь spring-context.

Итого: подключите org.springframework:spring-context:5.1.4.RELEASE.

Какие бывают контексты и как их создать?
У интерфейса ApplicationContext есть большое количество реализаций:
+ — ClassPathXmlApplicationContext;
+ — FileSystemXmlApplicationContext;
+ — GenericGroovyApplicationContext;
+ — AnnotationConfigApplicationContext;
+ — и даже StaticApplicationContext;
+ — а также некоторые другие.

Они отличаются друг от друга именно тем, каким способом задаются мета-данные и где хранится эта конфигурация. Например:
+ — ClassPathXmlApplicationContext — метаданные конфигурируются XML-файлом(-ами) и они лежат в classpath, т. е. в ресурсах модуля;
+ — FileSystemXmlApplicationContext — метаданные тоже конфигурируются XML-файлом(-ами), но они находятся где-то в файловой системе, например, /etc/yourapp/spring-context.xml;
+ — AnnotationConfigApplicationContext — метаданные конфигурируются с помощью аннотаций прямо на классах.

Современным способом конфигурирования считаются аннотации (AnnotationConfigApplicationContext), дальше будем создавать именно их. 

Приведём пример создания такого контекста в методе main:
```java
    @Configuration
    @ComponentScan
    public class Main {

        public static void main(String[] args) {
            AnnotationConfigApplicationContext context =
                    new AnnotationConfigApplicationContext(Main.class);
        }
    }
```
Внутри конструктора как раз и происходит инициализация контекста из мета-данных.
Как и полагается, в AnnotationConfigApplicationContext мета-данные конфигурируются аннотациями. Несложно заметить аннотацию @Configuration на Main-классе, и что он передаётся в конструктор контекста. Собственно, Main и есть описание метаданных.
+ [к оглавлению](#spring)

## Как можно связать бины?
__Явное и неявное связывание__
+ __неявная инъекция зависимостей, также называемую autowiring.__ 
Чтобы выполнить инъекцию, такие фреймворки будут искать в контексте подходящего кандидата. И потерпят неудачу, если не найдут ни одного подходящего класса или более одного.
+ __явное внедрение зависимостей__
В этом случае разработчику необходимо сконфигурировать инъекцию путем явной привязки отношения между объектом и зависимостью.
+ [к оглавлению](#spring)


## @Autowired, где можно ставить и какие есть отличия?
Аннотация __@Autowired__ применяется для неявного внедрения зависимости. Размещение аннотации определяет тип DI. Возможны три способа размещения. Над полем, сеттером, конструктором.

Ниже перечислены типы DI, которые предоставляет Spring:
+ __Constructor DI (через конструктор)__
DI через конструктор считается самым лучшим способом, т.к. для него не надо использовать рефлексию, а также он не имеет недостатков DI через сеттер.
DI через конструктор может приводить к циклическим зависимостям. Чтобы этого избежать, можно использовать ленивую инициализацию бинов или DI через сеттер.

Так же к плюсам относится (+):
в любой момент времени вы всегда получите готовый к работе класс со всеми зависимостями;
данные классы можно просто тестировать как обычные Java-классы и без поднятия контекста для тестирования;
в unit-тестах вы не сможете забыть добавить какую-либо зависимость, так как она будет требоваться на уровне компиляции.

+ __Setter DI (через сеттер)__
- Этот подход не является хорошей идеей, так как нет причин, по которым зависимость должна меняться во время жизненного цикла внедряемого объекта. 
- до того момента, как Spring проставит все зависимости в бин, экземпляр класса находится в некорректном состоянии. И обращение к зависимостям может привести к NullPointerException. Для того, чтобы сделать какие-то действия после того, как все зависимости будут инъектированы, используют аннотацию @PostConstruct.
+  тестировать эти классы почти так же просто, как и в случае DI через параметры конструктора. Но в тестах очень легко забыть проставить зависимость, не вызвав свежедобавленный сеттер.

+ __Field DI (через поле)__
+ Простота и минимум кода.
- DI через поле не рекомендуется использовать, т.к. для этого применяется рефлексия, снижающая производительность.
- Также, данный класс нельзя просто протестировать, не поднимая Spring Context. 
+ [к оглавлению](#spring)


## Опишите поведение аннотации @Autowired
+ 1.Контейнер определяет тип объекта для внедрения
+ 2.Контейнер ищет бины в контексте(он же контейнер), которые соответствуют нужному типу
+ 3.Если есть несколько кандидатов, и один из них помечен как @Primary, то внедряется он
+ 4.Если используется аннотации @Autowire + Qualifier, то контейнер будет использовать информацию из @Qualifier, чтобы понять, какой компонент внедрять
+ 5.В противном случае контейнер попытается внедрить компонент, основываясь на его имени или ID
+ 6.Если ни один из способов не сработал, то будет выброшено исключение

Контейнер обрабатывает DI с помощью AutowiredAnnotationBeanPostProcessor. В связи с этим, аннотация не может быть использована ни в одном BeanFactoryPP или BeanPP.

Если внедряемый объект массив, коллекция, или map с дженериком, то Spring внедрит все бины подходящие по типу в этот массив(или другую структуру данных). В случае с map ключом будет имя бина.
+ [к оглавлению](#spring)


## Что такое Dependency Injection? Чем отличается от композиции?
__Внедрение зависимостей__ — это специальный паттерн, который уменьшает связь между Spring компонентами. Таким образом, при применении DI, ваш код становится чище, проще, его становится легче понять и тестировать. 

Согласно паттерну DI, создание объектов для зависимостей переходит на фабрику или отдается третьей стороне. Это означает, что мы можем сосредоточиться на использовании этих объектов вместо их создания.

__Внедрение зависимостей (DI)__ - реализация принципа IoC — это стиль настройки объекта, при котором поля объекта задаются внешней сущностью. Другими словами, объекты настраиваются внешними объектами. 

Композиция - один из видов отношений классов в терминологии ООП. Таким образом DI также является и реализацией отношения - композиция.
+ [к оглавлению](#spring)


## Какие бины будут использоваться для настройки приложения?
Основными признаками и частями Java-конфигурации IoC контейнера являются классы с аннотацией `@Configuration` и методы с аннотацией `@Bean`. Аннотация `@Bean` используется для указания того, что метод создает, настраивает и инициализирует новый объект, управляемый Spring IoC контейнером. Такие методы можно использовать как в классах с аннотацией `@Configuration`, так и в классах с аннотацией `@Component`(или её наследниках). Класс с аннотацией `@Configuration` говорит о том, что он является источником определения бинов. 
+ [к оглавлению](#spring)


## принципы работы Spring.
Спринг решает несколько проблем связанных с разработкой приложений. Ключевыми среди них являются:
+ __Создание и управление объектами (IoC)__
+ 1.Мы описываем объекты, которые необходимы для работы нашего приложения (которые должны создаваться при запуске приложения) в конфигурационном файле.
+ 2.Спринг сам создает эти объекты и берёт на себя управление этими объектами (их жизненный цикл и много другое, например Scope Singleton). 
+ 3.Объекты размещаются в специальном контейнере Spring Application Context. И предоставляет объекты из него, по необходимости.
+ 4. Спринг сам внедряет все необходимые зависимости в объекты, связывает объекты между собой (у объектов есть ссылка на другие нужные им объекты). Нам необходимо только описать эту связь. Спринг делает всё остальное. Это называется Dependency Injection (DI).

+ __Удобный и эффективный доступ к БД__
+ __Приложение сервер, в архитектуре клиент-сервер.__
+ __Настройка разграничения доступа к данным__
+ [к оглавлению](#spring)


## Жизненный цикл Бина.
__Жизненный цикл__ - время существования класса. Spring бины инициализируются при инициализации Spring контейнера и происходит внедрение всех зависимостей. Когда контейнер уничтожается, то уничтожается и всё содержимое. Если нам необходимо задать какое-либо действие при инициализации и уничтожении бина, то нужно воспользоваться методами `init()` и `destroy()`. Для этого можно использовать аннотации `@PostConstruct` и `@PreDestroy()`.
```java
@PostConstruct
public void init(){
    System.out.println(“Bean init method called”);
}

@PreDestroy
public void destroy(){
    System.out.println(“Bean destroy method called”);
}
```
Или через xml конфигурацию:
```
<bean name="myBean" class="ru.javastudy.spring.MyBean"
        init-method="init" destroy-method="destroy">
    <property name="someProp" ref="someProp"></property>
</bean>
```
Для prototype бинов, спринг не вызывает метод дестрой. Об этом должен заботиться разработчик сам.

__Рассмотрим жизненный цикл более подробно:__

Через следующие этапы проходит каждый отдельно взятый бин:
+ 1.Инстанцирование объекта. Техническое начало жизни бина, работа конструктора его класса;
+ 2.Установка свойств из конфигурации бина, внедрение зависимостей;
+ 3.Нотификация aware-интерфейсов. BeanNameAware, BeanFactoryAware и другие. Мы уже писали о таких интерфейсах ранее. Технически, выполняется системными подтипами BeanPostProcessor, и совпадает с шагом 4;
+ 4.Пре-инициализация – метод postProcessBeforeInitialization() интерфейса BeanPostProcessor;
+ 5.Инициализация. Разные способы применяются в таком порядке:
+ Метод бина с аннотацией @PostConstruct из стандарта JSR-250 (рекомендуемый способ);
+ Метод afterPropertiesSet() бина под интерфейсом InitializingBean;
+ Init-метод. Для отдельного бина его имя устанавливается в параметре определения initMethod. В xml-конфигурации можно установить для всех бинов сразу, с помощью default-init-method;
+ 6.Пост-инициализация – метод postProcessAfterInitialization() интерфейса BeanPostProcessor.

Когда IoC-контейнер завершает свою работу, мы можем кастомизировать этап штатного уничтожения бина. Как со всеми способами финализации в Java, при жестком выключении (kill -9) гарантии вызова этого этапа нет. Три альтернативных способа «деинициализации» вызываются в том же порядке, что симметричные им методы инициализации:

Метод с аннотацией `@PreDestroy`;
Метод с именем, которое указано в свойстве `destroyMethod` определния бина (или в глобальном `default-destroy-method`);
Метод `destroy()` интерфейса `DisposableBean`.

Не следует путать жизненный цикл отдельного бина с жизненным циклом контекста и этапами подготовки фабрик бинов.
+ [к оглавлению](#spring)


## Основные паттерны Spring.
Вот некоторые известные паттерны, используемые в Spring Framework:
+ Proxy (Заместитель)
+ Singleton (Одиночка)
+ Factory (Фабрика)
+ Template (Шаблон)
+ Model View Controller (Модель-Представление-Контроллер)
+ Front Controller (Контроллер запросов)
+ View Helper (Вспомогательный компонент представления)
+ Dependency injection и Inversion of control (IoC) (Внедрение зависимостей и инверсия управления)
+ Service Locator (Локатор служб)
+ Observer-Observable (Наблюдатель)
+ Context Object (Контекстный объект)

[Подробная статья-->](https://habr.com/ru/company/otus/blog/451516/)
+ [к оглавлению](#spring)


## Рассказать про Singleton, как реализуется без Спринга?
Просто реализовать (Singleton) — достаточно скрыть конструктор и предоставить статический создающий метод.
```java
public final class Singleton {
    private static Singleton instance;
    public String value;

    private Singleton(String value) {
        // Этот код эмулирует медленную инициализацию.
        // К паттерну отношения не имеет.
        try {
            Thread.sleep(1000);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
        this.value = value;
    }

    public static Singleton getInstance(String value) {
        if (instance == null) {
            instance = new Singleton(value);
        }
        return instance;
    }
}
```
+ [к оглавлению](#spring)








# Spring MVC

## Как получить данные из файла .property?
```java 
@Configuration
@PropertySource("classpath:/com/myco/app.properties")
public class AppConfig {

   @Autowired
   Environment env;

   @Bean
   public TestBean testBean() {
       TestBean testBean = new TestBean();
       testBean.setName(env.getProperty("testbean.name"));
       return testBean;
   }
}
```
В наших проектах использовали этот, но есть и другие способы
[-->](https://issue.life/questions/9259819)
PropertyPlaceholderConfigurer
PropertySource
ResourceBundleMessageSource
PropertiesFactoryBean
и др.
+ [к оглавлению](#spring)


## Как запустить Спринг-приложение из-под сервера Tomcat? 
В приложении нет метода main, его запуск происходит из-под Tomcat и для этого требуется отдельный класс AppInit, который ссылается на корневой конфигурационный файл и обозначает, на каком url будет находиться наше приложение.

Развертывание WAR на Tomcat
Чтобы развернуть и запустить наш файл WAR в Tomcat в виде сервиса, нам нужно выполнить следующее:

Скопировать наш WAR-файл из target/spring-app.war в
папку tomcat/webapps/
Перейти к http://localhost : 8080/spring-app/hello
+ [к оглавлению](#spring)


## Что такое Artifacts?
__Артефакт__ - это сборка активов вашего проекта, которые вы собрали для тестирования, развертывания или распространения вашего программного решения или его части. Примерами являются набор скомпилированных классов Java или приложения Java, упакованных в архив Java, веб-приложение в виде структуры каталогов или архива веб-приложений и т. д.

Артефакт - это некая выходная сборка вашего проекта. В общем случае их может быть несколько: jar для десктопа и .war для веба ну и т.д.

Для каждого артефакта можно определить правила сборки, развертывания, запуска и т.д.

Есть артефакты в смысле Maven - это все тот же архив, но предназначенный для деплоймента на репозиторий maven
+ [к оглавлению](#spring)


## В чем отличие артефакта war от war exploded?
__Web Archive или Web Application Resource__ — формат файла, описывающий, как полное веб-приложение упаковывается в соответствии со спецификацией Java-сервлетов в файл в формате JAR или ZIP. Такие файлы имеют расширение «.war» и поэтому называются ещё «WAR-файлами».

war создаст только один файл war (который является просто архивом), а вариант с exploded — это просто «распакованный» war. Такой вариант позволяет быстрее деплоить мелкие изменения на сервер.
+ [к оглавлению](#spring)


## Какая разница между аннотациями @Component, @Repository и @Service в Spring?
Все они определяют бины Spring. Однако между ними всё же есть разница.

+ __@Component__ — универсальный компонент
+ __@Repository__ — компонент, который предназначен для хранения, извлечения и поиска. Как правило, используется для работы с базами данных.
+ __@Service__ — фасад для некоторой бизнес логики

Пользовательские аннотации, производные от `@Component`, могут добавлять специальную логику в бинах.

Например, бины, получившиеся при помощи `@Repository`, дополнительно имеют обработку для JDBC Exception.

`@Service` в настоящее время является псевдонимом `@Component`. Однако, в официальной документации Spring рекомендуется использовать именно `@Service` для бизнес логики. Вполне возможно, что в будущих версиях фреймворка, для данного стереотипа добавится дополнительная семантика, и его бины станут обладать дополнительной логикой.
+ [к оглавлению](#spring)


## Как выглядит структура MVC-приложения?
__MVC расшифровывается как Model — View — Controller.__ Это тип архитектуры приложения в которой логические части приложения условно разбиваются на три блока:
+ Модель
+ Вид
+ Контроллер

+ __Модель__  — отвечает за поведение приложения независимо от интерфейса пользователя. Модель относится к полному управлению данными, логикой и правилами приложения.
+ __Вид__ — это внешняя составляющая приложения. Это может быть HTML страница, диаграмма или UI.
+ __Контроллер__ — отвечает за получение входных и поток исходных данных. В его функции входит отслеживание действий пользователя.

Можно рассмотреть эту модель на примере кафе.
Официант — это контроллер. Он знает все варианты блюд из меню и может передать ваш заказ на кухню.
Повара на кухне — это модель. Они знают, какие взять ингредиенты и что с ними сделать, чтобы выполнить конкретный заказ.
Борщ — это представление. Речь об итоговом продукте, который пользователь сначала заказывает, а потом получает.
+ [к оглавлению](#spring)


## Какая основная зависимость фреймворка Спринг? Почему во многих сборках она не указывается явно?
+ __spring-core__ Т.к. включена во все артефакты.
+ [к оглавлению](#spring)


## Чем контроллер отличается от сервлета?
сервлет и контроллер Spring MVC могут использоваться для одного и того же, но они действуют на другом уровне приложения Java

сервлет является частью J2EE framework, и каждый сервер приложений Java (Tomcat, Jetty и т. д.) построен для запуска сервлетов. Сервлет-это слой "низкого уровня" в стеке J2EE. Тебе не нужен сервлет.jar для запуска приложения, потому что он упакован с сервером приложений

контроллер Spring MVC-это библиотека построенный на сервлете, чтобы сделать вещи проще. Spring MVC предлагает более встроенные функции, такие как параметр формы для отображения параметров метода контроллера, упрощение обработки двоичных представлений формы (т. е. когда ваша форма может загружать файлы). Вам нужно упаковать необходимые банки в приложение, чтобы запустить контроллер Spring MVC

вы должны использовать сервлет, когда вам нужно идти "низкий уровень", и пример может быть по причине производительности. Spring MVC работает хорошо, но если он имеет некоторые накладные расходы, если вам нужно выжать все, что вы можете с вашего сервера приложений (и вы уже настроили другие слои, такие как db), идут с сервлетом. Вы можете выбрать сервлет, если хотите понять основы веб-спецификаций J2EE (т. е. для образовательных целей)

во всех остальных случаях вы можете/должны выбрать веб-фреймворка. Spring MVC-один из них; с Spring MVC вам не нужно изобретать колесо (i.e бинарное управление формой, параметр формы к преобразование фасоли,проверка параметров и так далее). Еще один плюс Spring MVC заключается в том, что в одном классе вы можете легко управлять вводом из разных URL-адресов и методов, делая то же самое в сервлете, но код более сложный и менее читаемый. Я считаю, что Spring MVC хорош для создания служб rest и управления простыми приложениями (i.e веб-приложение с простыми формами). Если вам нужно управлять очень сложными формами с Ajax, вложенными формами и приложением с сеансом и состояние страницы мой совет-переключиться на компонентную структуру (например,apache калитка например).
+ [к оглавлению](#spring)


## Как вернуть страницу в контроллере? Как вернуть данные?



+ [к оглавлению](#spring)


## Как интегрировать Hibernate и Spring?
Оба фреймворка поддерживают интеграцию из коробки и в общем настройка их взаимодействия не составляет труда. Общие шаги выглядят следующим образом.

+ 1.Добавить зависимости для hibernate-entitymanager, hibernate-core и spring-orm.
+ 2.Создать классы модели и передать реализации DAO операции над базой данных. Важно, что DAO классы используют SessionFactory, который внедряется в конфигурации бинов Spring.
+ 3.Настроить конфигурационный файл Spring для Hibernate.
+ 4.Дополнительно появляется возможность использовать аннотацию @Transactional и перестать беспокоиться об управлении транзакцией Hibernate.
+ [к оглавлению](#spring)


