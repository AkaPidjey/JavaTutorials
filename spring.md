[Java Tutorials](README.md)

# Spring

## Spring Core
+ [Что такое Spring? Чем фреймворк отличается от библиотеки?](#Что-такое-Spring-Чем-фреймворк-отличается-от-библиотеки)
+ [Что такое бины?](#Что-такое-бины)
+ [Назовите способы создания бинов?](#Назовите-способы-создания-бинов)
+ [Виды бинов? Скоупы бинов? Какой по-умолчанию?](#Виды-бинов-Скоупы-бинов-Какой-по-умолчанию)
+ [Чем бин отличается от POJO-класса?](#Чем-бин-отличается-от-POJO-класса)
+ [Что такое Inversion of Control и как Spring реализует этот принцип?](#Что-такое-Inversion-of-Control-и-как-Spring-реализует-этот-принцип)
+ [Что такое контекст Spring и как его создать?](#Что-такое-контекст-Spring-и-как-его-создать)
+ [Как можно связать бины?](#Как-можно-связать-бины)
+ [@Autowired, где можно ставить и какие есть отличия?](#Autowired-где-можно-ставить-и-какие-есть-отличия)
+ [Опишите поведение аннотации @Autowired](#Опишите-поведение-аннотации-Autowired)
+ [Что такое Dependency Injection? Чем отличается от композиции?](#Что-такое-Dependency-Injection-Чем-отличается-от-композиции)
+ [Какие бины будут использоваться для настройки приложения?](#Какие-бины-будут-использоваться-для-настройки-приложения)



## Spring Security




+ [к оглавлению](#spring)






## Что такое Spring? Чем фреймворк отличается от библиотеки?
Spring Framework - представляет собой просто контейнер внедрения зависимостей, с несколькими удобными слоями (например: доступ к базе данных, прокси, аспектно-ориентированное программирование, RPC, веб-инфраструктура MVC). Это все позволяет вам быстрее и удобнее создавать Java-приложения.


«Фреймворк» отличается от понятия библиотеки тем, что библиотека может быть использована в программном продукте просто как набор подпрограмм близкой функциональности, не влияя на архитектуру программного продукта и не накладывая на неё никаких ограничений. В то время как «фреймворк» диктует правила построения архитектуры приложения, задавая на начальном этапе разработки поведение по умолчанию — «каркас», который нужно будет расширять и изменять, согласно указанным требованиям.

Также, в отличие от библиотеки, которая объединяет в себе набор близкой функциональности, — «фреймворк» может содержать в себе большое число разных по тематике библиотек.

Другим ключевым отличием «фреймворка» от библиотеки может быть инверсия управления: пользовательский код вызывает функции библиотеки (или классы) и получает управление после вызова. Во «фреймворке» пользовательский код может реализовывать конкретное поведение, встраиваемое в более общий — «абстрактный» код фреймворка. При этом «фреймворк» вызывает функции (классы) пользовательского кода.
+ [к оглавлению](#spring)


## Что такое бины?
Начнем срывать покровы с самых базовых понятий Spring. Бин (bean) — это не что иное, как самый обычный объект. Разница лишь в том, что бинами принято называть те объекты, которые управляются Spring-ом и живут внутри его DI-контейнера. Бином является почти все в Spring — сервисы, контроллеры, репозитории, по сути все приложение состоит из набора бинов. Их можно регистрировать, получать в качестве зависимостей, проксировать, мокать и т.п.
+ [к оглавлению](#spring)


## Назовите способы создания бинов?
__Существует 4 способа создания бинов:__
+ xml - старый способ, как преимущество - централизованная конфигурация контекста
+ аннотации - простота и удобство, как недостаток - децентрализованная конфигурация
+ Java конфигурация - пока лучший способ.
+ Groovy - заменит и java и xml, но пока он не достаточно хорош.

+ __XML__

Исторически конфигурирование контекста c использованием XML было первым методом конфигурирования, появившемся в Spring.
Конфигурирование с помощью XML заключается в создании xml файла (традиционно носящего названия вида «context.xml», «applicationContext.xml» и т.д.), описывающего Spring beans, процесс их создания и взаимосвязи между ними. 
Не использует аннотаций.
```java
    <bean id="coin" class="stas.paliutin.spring.CoinImpl">
        <constructor-arg type="java.util.Random">
            <bean class="java.util.Random"/>
        </constructor-arg>
    </bean>
```
Вначале мы определили бин «coin», передав ему в конструктор внутренний анонимный бин, созданный из java.util.Random. Связывание было проведено по типу аргумента, а передаваемый в конструктор бин был определён на месте.

+ __Аннотации__
```java
ApplicationContext context = 
	new AnnotationConfigApplicationContext("where.is.entities");
```
Сначала мы создаем объект контекста, и в конструкторе указываем ему имя пакета, которое надо сканировать на наличие в нем бинов.
Второй способ сделать это, через указание аннотации @ComponentScan(“...”) вместе с @Configuration. 
```java
@Configuration
@ComponentScan("where.is.entities")
public class WebConfig {
    private static ApplicationContext applicationContext;

    public WebConfig(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
```
То-есть, спринг пройдется по этому пакету и попробует найти такие классы, которые отмечены специальными аннотациями, дающими спрингу понять, что это — бин. После чего он создает объекты этих классов и помещает их себе в контекст.
Сами бины для сканирования помечаются через аннотации @Component и все остальные аннотации, которые наследуются от этой. Например, @Controller, @RestController, @Service, @Repository и другие.
Имя бина будет именем класса с маленькой буквы. Либо можно специально указать в () аннотации.
```java
@Component(“myBean”);
```
Суть: Пишете ваши классы, отмечаете их нужными аннотациями, и указываете спрингу пакет с вашими классами, по которому он идет, ищет аннотации и создает объекты таких классов.

+ __JAVA конфигурация__

Чтобы создать класс с конфигурацией на основе Java-кода, нужно аннотировать его с помощью
@Configuration.
Spring вызывает в конфигурационных классах методы с аннотацией @Bean. Объекты, возвращённые этими методами, регистрируются как Spring бины. Названия бинов соответствуют названиям методов, которые их порождают.
```java
    @Bean
    public Cat cat() {
        return new Cat(“Meoy”);
    }
```
Java конфигурация выглядит наилучшим образом, если сравнивать её достоинства и недостатки. Это и централизованность как в xml; и безопасность типов; и простой рефакторинг; и отсутствия spring специфичных вещей в коде; и возможность выполнения каких-либо действий на этапе конфигурации. К недостаткам, пожалуй, относится необходимость ручного создания бинов и необходимость пересборки для переконфигурации приложения.

Важно и название класса конфигурации: несмотря на искушение назвать конфигурационный класс Context, делать этого не следует. Дело в том, что Spring создаст бин и из этого класса, а в качестве имени использует имя класса. А имя «Context» уже занято самим Spring.

+ __Groovy__

Поддержка Groovy скриптов и специального beans DSL появилась в 4 версии Spring как попытка сделать конфигурацию вообще без недостатков. Groovy конфигурация должна объединить в себе достоинства XML конфигурации и Java конфигурации, оставаясь дружественной к аннотациям.
К достоинствам groovy конфигурации можно отнести всё хорошее, что есть в XML и Java подходах: централизованное описание приложения, которое может хранится отдельно от кода, позволяя менять структуру приложения без пересборки (а в перспективе без перезапуска); использование стороннего кода в качестве Spring beans; возможность сохранить код чистым от Spring аннотаций; безопасность типов и простота рефакторинга; выполнение кода на этапе конфигурирования. Однако поддержка groovy конфигурации ещё недостаточно доработана и не все возможности, достижимые с помощью xml/java, доступны с groovy.
+ [к оглавлению](#spring)


## Виды бинов? Скоупы бинов? Какой по-умолчанию?
Бины можно классифицировать по функциональной роли и по “Скоупу” (во многих источниках “области видимости”)
По функциональному назначение бины могут аннотироваться разным способом (Стереотипы):
+ __@Component__ - бин общего назначения
+ __@Controller__ - контроллер в архитектуре MVC
+ __@Service__ - сервисный слой
+ __@Repository__ - дао слой

__Scope бинов__
Область видимости указывается с помощью аннотации @Scope на @Bean методах или .
+ __singleton__ 
Определяет один единственный бин для каждого контейнера Spring IoC (используется по умолчанию).
+ __prototype__
Позволяет иметь любое количество экземпляров бина.
+ __request__
Создаётся один экземпляр бина на каждый HTTP запрос. Касается исключительно ApplicationContext.
+ __session__
Создаётся один экземпляр бина на каждую HTTP сессию. Касается исключительно ApplicationContext.
+ __global-session__
Создаётся один экземпляр бина на каждую глобальную HTTP сессию. Касается исключительно ApplicationContext.

По умолчанию бину присваивается Скоуп singleton.
+ [к оглавлению](#spring)



## Чем бин отличается от POJO-класса?
__POJO (англ. Plain Old Java Object)__ — «старый добрый Java-объект», простой Java-объект, не унаследованный от какого-то специфического объекта и не реализующий никаких служебных интерфейсов сверх тех, которые нужны для бизнес-модели.

Все JavaBeans - это POJO, но не все POJO - это JavaBeans.

JavaBean - это объект Java, который удовлетворяет определенным соглашениям о программном обеспечении:
+ 1 - класс JavaBean должен реализовывать либо Serializable, либо Externalizable;
+ 2 - класс JavaBean должен иметь открытый конструктор no-arg;
+ 3 - все свойства JavaBean должны иметь общедоступные методы setter и getter (в зависимости от ситуации);
+ 4 - все переменные экземпляра JavaBean должны быть частными.
+ [к оглавлению](#spring)

## Что такое Inversion of Control и как Spring реализует этот принцип?
__Inversion of Control (инверсия управления)__ — это некий абстрактный принцип, набор рекомендаций для написания слабо связанного кода. Суть которого в том, что каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов.
__Как Spring реализует этот принцип?__
Центральной частью Spring является контейнер Inversion of Control, который предоставляет средства конфигурирования и управления объектами Java с помощью рефлексии. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой и т.д.

Объекты, создаваемые контейнером, также называются управляемыми объектами (beans). Обычно, конфигурирование контейнера, осуществляется путём внедрения аннотаций (начиная с 5 версии J2SE), но также, есть возможность, по старинке, загрузить XML-файлы, содержащие определение bean’ов и предоставляющие информацию, необходимую для создания bean’ов.

#### [Концепция Inversion of Control и основы Spring-->]( http://javatutor.net/articles/spring-basic-and-inversion-of-control )
#### [Инверсии зависимостей управления впрыском-->]( https://habr.com/ru/post/321344/ )
#### [Spring для домохозяек. Inversion of Control на практике.-->]( https://nikcode.blogspot.com/2011/09/spring-inversion-of-control.html )
+ [к оглавлению](#spring)

## Что такое контекст Spring и как его создать?
Контекст (а у него есть даже интерфейс — org.springframework.context.ApplicationContext) — это некоторое окружение, в котором работает приложение на Spring Framework. Страшные аббревиатуры DI, IoC — это всё про него. Собственно, контекст создаёт и хранит экземпляры классов вашего приложения, определяет их зависимости друг с другом и автоматически их задаёт.

Безусловно, для того чтобы Spring создал контекст с экземплярами классов, ему нужно предоставить дополнительную информацию — мета-данные, из каких классов/объектов состоит ваше приложение, как они создаются, какие у них есть зависимости и т. д.

Итого: Spring Context + мета-данные = работающее приложение.

Где найти контекст?
Контекст является ключевой функциональностью Spring и лежит в maven-зависимости spring-context (на момент написания — org.springframework:spring-context:5.1.4.RELEASE). Обычно эта зависимость является транзитивной для остальных проектов Spring. И если вы, например, подключаете spring-boot-starter, то она подключится автоматически, и не нужно думать про то, где её взять.

Но если вы хотите попробовать "голый" Spring, т. е. только ту часть, которая называется IoC-контейнер, то достаточно подключить лишь spring-context.

Итого: подключите org.springframework:spring-context:5.1.4.RELEASE.

Какие бывают контексты и как их создать?
У интерфейса ApplicationContext есть большое количество реализаций:
+ — ClassPathXmlApplicationContext;
+ — FileSystemXmlApplicationContext;
+ — GenericGroovyApplicationContext;
+ — AnnotationConfigApplicationContext;
+ — и даже StaticApplicationContext;
+ — а также некоторые другие.

Они отличаются друг от друга именно тем, каким способом задаются мета-данные и где хранится эта конфигурация. Например:
+ — ClassPathXmlApplicationContext — метаданные конфигурируются XML-файлом(-ами) и они лежат в classpath, т. е. в ресурсах модуля;
+ — FileSystemXmlApplicationContext — метаданные тоже конфигурируются XML-файлом(-ами), но они находятся где-то в файловой системе, например, /etc/yourapp/spring-context.xml;
+ — AnnotationConfigApplicationContext — метаданные конфигурируются с помощью аннотаций прямо на классах.

Современным способом конфигурирования считаются аннотации (AnnotationConfigApplicationContext), дальше будем создавать именно их. 

Приведём пример создания такого контекста в методе main:
```java
    @Configuration
    @ComponentScan
    public class Main {

        public static void main(String[] args) {
            AnnotationConfigApplicationContext context =
                    new AnnotationConfigApplicationContext(Main.class);
        }
    }
```
Внутри конструктора как раз и происходит инициализация контекста из мета-данных.
Как и полагается, в AnnotationConfigApplicationContext мета-данные конфигурируются аннотациями. Несложно заметить аннотацию @Configuration на Main-классе, и что он передаётся в конструктор контекста. Собственно, Main и есть описание метаданных.
+ [к оглавлению](#spring)

## Как можно связать бины?
__Явное и неявное связывание__
+ __неявная инъекция зависимостей, также называемую autowiring.__ 
Чтобы выполнить инъекцию, такие фреймворки будут искать в контексте подходящего кандидата. И потерпят неудачу, если не найдут ни одного подходящего класса или более одного.
+ __явное внедрение зависимостей__
В этом случае разработчику необходимо сконфигурировать инъекцию путем явной привязки отношения между объектом и зависимостью.
+ [к оглавлению](#spring)


## @Autowired, где можно ставить и какие есть отличия?
Аннотация __@Autowired__ применяется для неявного внедрения зависимости. Размещение аннотации определяет тип DI. Возможны три способа размещения. Над полем, сеттером, конструктором.

Ниже перечислены типы DI, которые предоставляет Spring:
+ __Constructor DI (через конструктор)__
DI через конструктор считается самым лучшим способом, т.к. для него не надо использовать рефлексию, а также он не имеет недостатков DI через сеттер.
DI через конструктор может приводить к циклическим зависимостям. Чтобы этого избежать, можно использовать ленивую инициализацию бинов или DI через сеттер.

Так же к плюсам относится (+):
в любой момент времени вы всегда получите готовый к работе класс со всеми зависимостями;
данные классы можно просто тестировать как обычные Java-классы и без поднятия контекста для тестирования;
в unit-тестах вы не сможете забыть добавить какую-либо зависимость, так как она будет требоваться на уровне компиляции.

+ __Setter DI (через сеттер)__
- Этот подход не является хорошей идеей, так как нет причин, по которым зависимость должна меняться во время жизненного цикла внедряемого объекта. 
- до того момента, как Spring проставит все зависимости в бин, экземпляр класса находится в некорректном состоянии. И обращение к зависимостям может привести к NullPointerException. Для того, чтобы сделать какие-то действия после того, как все зависимости будут инъектированы, используют аннотацию @PostConstruct.
+  тестировать эти классы почти так же просто, как и в случае DI через параметры конструктора. Но в тестах очень легко забыть проставить зависимость, не вызвав свежедобавленный сеттер.

+ __Field DI (через поле)__
+ Простота и минимум кода.
- DI через поле не рекомендуется использовать, т.к. для этого применяется рефлексия, снижающая производительность.
- Также, данный класс нельзя просто протестировать, не поднимая Spring Context. 
+ [к оглавлению](#spring)


## Опишите поведение аннотации @Autowired
+ 1.Контейнер определяет тип объекта для внедрения
+ 2.Контейнер ищет бины в контексте(он же контейнер), которые соответствуют нужному типу
+ 3.Если есть несколько кандидатов, и один из них помечен как @Primary, то внедряется он
+ 4.Если используется аннотации @Autowire + Qualifier, то контейнер будет использовать информацию из @Qualifier, чтобы понять, какой компонент внедрять
+ 5.В противном случае контейнер попытается внедрить компонент, основываясь на его имени или ID
+ 6.Если ни один из способов не сработал, то будет выброшено исключение

Контейнер обрабатывает DI с помощью AutowiredAnnotationBeanPostProcessor. В связи с этим, аннотация не может быть использована ни в одном BeanFactoryPP или BeanPP.

Если внедряемый объект массив, коллекция, или map с дженериком, то Spring внедрит все бины подходящие по типу в этот массив(или другую структуру данных). В случае с map ключом будет имя бина.
+ [к оглавлению](#spring)


## Что такое Dependency Injection? Чем отличается от композиции?
__Внедрение зависимостей__ — это специальный паттерн, который уменьшает связь между Spring компонентами. Таким образом, при применении DI, ваш код становится чище, проще, его становится легче понять и тестировать. 

Согласно паттерну DI, создание объектов для зависимостей переходит на фабрику или отдается третьей стороне. Это означает, что мы можем сосредоточиться на использовании этих объектов вместо их создания.

__Внедрение зависимостей (DI)__ - реализация принципа IoC — это стиль настройки объекта, при котором поля объекта задаются внешней сущностью. Другими словами, объекты настраиваются внешними объектами. 

Композиция - один из видов отношений классов в терминологии ООП. Таким образом DI также является и реализацией отношения - композиция.
+ [к оглавлению](#spring)


## Какие бины будут использоваться для настройки приложения?
Основными признаками и частями Java-конфигурации IoC контейнера являются классы с аннотацией `@Configuration` и методы с аннотацией `@Bean`. Аннотация `@Bean` используется для указания того, что метод создает, настраивает и инициализирует новый объект, управляемый Spring IoC контейнером. Такие методы можно использовать как в классах с аннотацией `@Configuration`, так и в классах с аннотацией `@Component`(или её наследниках). Класс с аннотацией `@Configuration` говорит о том, что он является источником определения бинов. 
+ [к оглавлению](#spring)



