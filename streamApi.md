[Java Tutorials](README.md)

# Stream API и Лямбда.
+ [Что такое _«лямбда»_? Какова структура и особенности использования лямбда-выражения?](#Что-такое-лямбда-Какова-структура-и-особенности-использования-лямбда-выражения)
+ [К каким переменным есть доступ у лямбда-выражений?](#К-каким-переменным-есть-доступ-у-лямбда-выражений)
+ [Как отсортировать список строк с помощью лямбда-выражения?](#Как-отсортировать-список-строк-с-помощью-лямбда-выражения)
+ [Что такое «ссылка на метод»? Какие виды ссылок на методы вы знаете?](#Что-такое-ссылка-на-метод-Какие-виды-ссылок-на-методы-вы-знаете)
+ [Объясните выражение `System.out::println`.](#Объясните-выражение-systemoutprintln)
+ [Любой анонимный класс можно заменить на лямбду?](#Любой-анонимный-класс-можно-заменить-на-лямбду)
+ [Связь лямбда с анонимным классом?](#Связь-лямбда-с-анонимным-классом)

+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)


## Что такое _«лямбда»_? Какова структура и особенности использования лямбда-выражения?
__Лямбда__ представляет собой набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.

Основу лямбда-выражения составляет _лямбда-оператор_, который представляет стрелку `->`. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая собственно представляет тело лямбда-выражения, где выполняются все действия.

Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.

```java
interface Operationable {
    int calculate(int x, int y);
}

public static void main(String[] args) {
    Operationable operation = (x, y) -> x + y;     
    int result = operation.calculate(10, 20);
    System.out.println(result); //30
}
```

По факту лямбда-выражения являются в некотором роде сокращенной формой внутренних анонимных классов, которые ранее применялись в Java.

+ _Отложенное выполнение (deferred execution) лямбда-выражения_- определяется один раз в одном месте программы, вызываются при необходимости, любое количество раз и в произвольном месте программы.

+ _Параметры лямбда-выражения_ должны соответствовать по типу параметрам метода функционального интерфейса:

```java
operation = (int x, int y) -> x + y;
//При написании самого лямбда-выражения тип параметров разрешается не указывать:
(x, y) -> x + y;
//Если метод не принимает никаких параметров, то пишутся пустые скобки, например,
() -> 30 + 20;
//Если метод принимает только один параметр, то скобки можно опустить:
n -> n * n;
```

+ _Конечные лямбда-выражения_ не обязаны возвращать какое-либо значение.

```java
interface Printable {
    void print(String s);
}
 
public static void main(String[] args) {
    Printable printer = s -> System.out.println(s);
    printer.print("Hello, world");
}
```

+ _Блочные лямбда-выражения_ обрамляются фигурными скобками. В блочных лямбда-выражениях можно использовать внутренние вложенные блоки, циклы, конструкции `if`, `switch`, создавать переменные и т.д. Если блочное лямбда-выражение должно возвращать значение, то явным образом применяется оператор `return`:

```java
Operationable operation = (int x, int y) -> {       
    if (y == 0) {
        return 0;
    }
    else {
        return x / y;
    }
};
```

+ _Передача лямбда-выражения в качестве параметра метода_:

```java
interface Condition {
    boolean isAppropriate(int n);
}

private static int sum(int[] numbers, Condition condition) {
    int result = 0;
    for (int i : numbers) {
        if (condition.isAppropriate(i)) {
            result += i;
        }
    }
    return result;
}

public static void main(String[] args) {
    System.out.println(sum(new int[] {0, 1, 0, 3, 0, 5, 0, 7, 0, 9}, (n) -> n != 0));
} 
```

[к оглавлению](#Stream-API-и-Лямбда)

## К каким переменным есть доступ у лямбда-выражений?
Доступ к переменным внешней области действия из лямбда-выражения очень схож к доступу из анонимных объектов. Можно ссылаться на:

+ неизменяемые (_effectively final_ - не обязательно помеченные как `final`) локальные переменные;
Либо явно финализирована, либо не переписана.
```java
final int bonus = 10;
IntUnaryOperator bonusAdder = (x) -> x + bonus;

Для обхода этого ограничения используют массив единичной длины
int[] counter = new int[1];
IntSupplier sequence1 = () -> counter[0]++;
```
+ поля класса;
+ статические переменные.
+ к параметрам лямбда-выражения, а также свободно объявлять и использовать внутри тела лямбда-выражения любые переменные ???

!!! К методам по умолчанию реализуемого функционального интерфейса обращаться внутри лямбда-выражения запрещено.

[к оглавлению](#Stream-API-и-Лямбда)

## Как отсортировать список строк с помощью лямбда-выражения?
```java
public static List<String> sort(List<String> list){
    Collections.sort(list, (a, b) -> a.compareTo(b));
    return list;
}
```

[к оглавлению](#Stream-API-и-Лямбда)

## Что такое «ссылка на метод»? Какие виды ссылок на методы вы знаете?
Если существующий в классе метод уже делает все, что необходимо, то можно воспользоваться механизмом __method reference (ссылка на метод)__ для непосредственной передачи этого метода. Такая ссылка передается в виде:

+ `ContainingClass::staticMethodName` - Ссылка на статический метод;
+ `containingObject::instanceMethodName` - Ссылка на нестатический метод конкретного объекта;
+ `ContainingType::methodName` - Ссылка на нестатический метод любого объекта конкретного типа;
+ `ClassName::new` - Ссылка на конструктор;

Результат будет в точности таким же, как в случае определения лямбда-выражения, которое вызывает этот метод.

```java
private interface Measurable {
    public int length(String string);
}

public static void main(String[] args) {
    Measurable a = String::length;
    System.out.println(a.length("abc"));
}
```

Ссылки на методы потенциально более эффективны, чем использование лямбда-выражений. Кроме того, они предоставляют компилятору более качественную информацию о типе и при возможности выбора между использованием ссылки на существующий метод и использованием лямбда-выражения, следует всегда предпочитать использование ссылки на метод.

[к оглавлению](#Stream-API-и-Лямбда)


## Объясните выражение `System.out::println`.
Данное выражение иллюстрирует механизм _instance method reference_: передачи ссылки на метод `println()` статического поля `out` класса `System`.

[к оглавлению](#Stream-API-и-Лямбда)

## Любой анонимный класс можно заменить на лямбду?
+ Ответ - нет. 
Вы можете создать анонимный класс для не финальных классов и интерфейсов. Не то же самое для лямбда-выражений. Они могут использоваться только там, где ожидается интерфейс SAM, то есть интерфейсы только с одним абстрактным методом (до Java 8 каждый интерфейсный метод был абстрактным, но поскольку интерфейсы Java 8 также могут иметь стандартные и статические методы, которые не являются абстрактными, поскольку они имеют реализацию 

**(!)Только анонимные классы, которые являются реализациями интерфейса SAM (например, Runnable, ActionListener, Comparator, Predicate), могут быть заменены лямбда-выражением. DefaultConsumer не может быть лямбда-мишенью, потому что даже не является интерфейсом.

[к оглавлению](#Stream-API-и-Лямбда)

## Связь лямбда с анонимным классом?
+ __Заменяют анонимные классы, синтаксический сахар, не нужно переопределять методы__.
+ __Что такое «анонимные классы»? Где они применяются?__
- Это вложенный локальный(inner class) класс, без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений. 
- Нет конструктора, только тело
- Создание экземпляра анонимного класса происходит одновременно с его объявлением. В зависимости от местоположения анонимный класс ведет себя как статический, либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.
Анонимные классы имеют несколько ограничений:
•	Их использование разрешено только в одном месте программы - месте его создания;
•	Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
•	Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.
Анонимные классы обычно применяются для:
•	создания объекта функции (function object), например, реализация интерфейса Comparator;
•	создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;
•	в статическом методе генерации;
•	инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.
+ Анонимные классы выполняют две функции, 
1.	Описание класса

2.	Создание экземпляра(объекта) этого класса

+ __Как создать экземпляр анонимного класса (подробно)?__ 
1. Создаем локальный класс без имени, 
2. Можно объявить такой класс, который может расширить (extends) другой класс или реализовать (implements) интерфейс. Объявление такого класса выполняется одновременно с созданием его объекта посредством оператора new и экземпляр некоторого класса.
3. Не должно быть конструктора, 
```java
UnaryOperator<Integer> myOperatorWithoutName = new UnaryOperator<Integer>() {
        @Override
        public Integer apply(Integer x) {
            return x * x;
        }
    };
```
Любые аргументы, которые вы укажете в круглых скобках, стоящих за именем родительского класса в определении анонимного класса, неявно передаются конструктору родительского класса.
+ __Где применяются анонимные классы?__ 
1) Чаще всего анонимные классы применяются для расширения родительских классов простыми классами, которые не требуют аргументов конструктора, поэтому скобки в определении анонимного класса зачастую пусты.
2) Чтобы не создавать отдельный класс, если нужно встроить некоторую логику в существующий класс или связать с др.классом.
3) При обращении создается единожды, Анонимный внутренний класс может быть полезен при создании экземпляра объекта с определенными "extras", такими как переопределяющие методы, без необходимости фактически подклассировать класс.

Когда мы реализуем один единственный метод интерфейса, то нет необходимости его указывать в реализации,  
Я обычно использую его как ярлык для подключения прослушивателя событий:
public void addActionListener(ActionListener listener) {
		listeners.add(listener);

button.addActionListener(new ActionListener() {
   ```java
    @Override
    public void actionPerformed(ActionEvent e) { //описание структуры анонимного класса
        // do something
    }
});
```
1.	Нет необходимости явно указывать:
- сам интерфейс, потому что на этапе компиляции он видит заголовок в параметрах метода принимающего значения, 
т.е.:
```java
public void addActionListener(ActionListener listener) {
```
- имя самого метода (поскольку это ФИ и у него единственный метод,) понятно что речь идет только о нем, 
- возвращаемое значение,
- модификаторы доступа,
2.	Чтобы разделить набор параметров, которые мы указываем в круглых скобочках и тело метода реализующего метод интерфейса, после указания аргументов, в скобочках, мы указываем в виде стрелочки, ->
3.	То, во что вырождается анонимный класс называется Лямбда-выражение
Если у метода, в интерфейсе, есть параметры, то типы этих параметров можно не писать, т.к. компилятор узнает эти типы заглянув в заголовок в интерфейсе, а об интерфейсе он узнает из метода public void addActionListener(ActionListener listener) {
4.	Если у метода интерфейса единственный параметр, то можно опустить и круглые скобки, но если их нет совсем, то они должны быть пустые.
5.	Если тело состоит из единственного оператора, фигурные скобки можно опустить, ; (точка с запятой не записывается сразу после тела,
6.	Если единственный оператор это return то он тоже опускается.

[к оглавлению](#Stream-API-и-Лямбда)

## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ
#### [Шпаргалка Java программиста 4. Java Stream API-->]( https://habr.com/ru/company/luxoft/blog/270383/ )
#### [Stream API: универсальная промежуточная операция-->]( https://habr.com/ru/post/262139/ )
#### [Stream API-->]( https://javarush.ru/groups/posts/2203-stream-api )
#### [Полное руководство по Java 8 Stream API в картинках и примерах-->]( https://annimon.com/article/2778 )
#### [Полное руководство по Java Stream API-->]( https://hr-vector.com/java/stream-api )
#### [Введение в Stream API-->]( https://metanit.com/java/tutorial/10.1.php )
#### [Interface Stream<T>-->]( https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html )
#### [Stream API и лямбда выражения в Java.-->]( https://java-master.com/stream-and-lambda-in-java/ )
#### [Использование generic wildcards для повышения удобства Java API-->]( https://habr.com/ru/post/207360/ )
#### [Название-->]( Ссылка )
#### [Название-->]( Ссылка )
#### [Название-->]( Ссылка )

[к оглавлению](#Stream-API-и-Лямбда)
