[Java Tutorials](README.md)

# Stream API и Лямбда.
+ [Что такое _«лямбда»_? Какова структура и особенности использования лямбда-выражения?](#Что-такое-лямбда-Какова-структура-и-особенности-использования-лямбда-выражения)
+ [К каким переменным есть доступ у лямбда-выражений?](#К-каким-переменным-есть-доступ-у-лямбда-выражений)
+ [Как отсортировать список строк с помощью лямбда-выражения?](#Как-отсортировать-список-строк-с-помощью-лямбда-выражения)
+ [Что такое «ссылка на метод»? Какие виды ссылок на методы вы знаете?](#Что-такое-ссылка-на-метод-Какие-виды-ссылок-на-методы-вы-знаете)
+ [Объясните выражение `System.out::println`.](#Объясните-выражение-systemoutprintln)


+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)


## Что такое _«лямбда»_? Какова структура и особенности использования лямбда-выражения?
__Лямбда__ представляет собой набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.

Основу лямбда-выражения составляет _лямбда-оператор_, который представляет стрелку `->`. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая собственно представляет тело лямбда-выражения, где выполняются все действия.

Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.

```java
interface Operationable {
    int calculate(int x, int y);
}

public static void main(String[] args) {
    Operationable operation = (x, y) -> x + y;     
    int result = operation.calculate(10, 20);
    System.out.println(result); //30
}
```

По факту лямбда-выражения являются в некотором роде сокращенной формой внутренних анонимных классов, которые ранее применялись в Java.

+ _Отложенное выполнение (deferred execution) лямбда-выражения_- определяется один раз в одном месте программы, вызываются при необходимости, любое количество раз и в произвольном месте программы.

+ _Параметры лямбда-выражения_ должны соответствовать по типу параметрам метода функционального интерфейса:

```java
operation = (int x, int y) -> x + y;
//При написании самого лямбда-выражения тип параметров разрешается не указывать:
(x, y) -> x + y;
//Если метод не принимает никаких параметров, то пишутся пустые скобки, например,
() -> 30 + 20;
//Если метод принимает только один параметр, то скобки можно опустить:
n -> n * n;
```

+ _Конечные лямбда-выражения_ не обязаны возвращать какое-либо значение.

```java
interface Printable {
    void print(String s);
}
 
public static void main(String[] args) {
    Printable printer = s -> System.out.println(s);
    printer.print("Hello, world");
}
```

+ _Блочные лямбда-выражения_ обрамляются фигурными скобками. В блочных лямбда-выражениях можно использовать внутренние вложенные блоки, циклы, конструкции `if`, `switch`, создавать переменные и т.д. Если блочное лямбда-выражение должно возвращать значение, то явным образом применяется оператор `return`:

```java
Operationable operation = (int x, int y) -> {       
    if (y == 0) {
        return 0;
    }
    else {
        return x / y;
    }
};
```

+ _Передача лямбда-выражения в качестве параметра метода_:

```java
interface Condition {
    boolean isAppropriate(int n);
}

private static int sum(int[] numbers, Condition condition) {
    int result = 0;
    for (int i : numbers) {
        if (condition.isAppropriate(i)) {
            result += i;
        }
    }
    return result;
}

public static void main(String[] args) {
    System.out.println(sum(new int[] {0, 1, 0, 3, 0, 5, 0, 7, 0, 9}, (n) -> n != 0));
} 
```

[к оглавлению](#Stream-API-и-Лямбда)

## К каким переменным есть доступ у лямбда-выражений?
Доступ к переменным внешней области действия из лямбда-выражения очень схож к доступу из анонимных объектов. Можно ссылаться на:

+ неизменяемые (_effectively final_ - не обязательно помеченные как `final`) локальные переменные;
Либо явно финализирована, либо не переписана.
```java
final int bonus = 10;
IntUnaryOperator bonusAdder = (x) -> x + bonus;

Для обхода этого ограничения используют массив единичной длины
int[] counter = new int[1];
IntSupplier sequence1 = () -> counter[0]++;
```
+ поля класса;
+ статические переменные.

К методам по умолчанию реализуемого функционального интерфейса обращаться внутри лямбда-выражения запрещено.

[к оглавлению](#Stream-API-и-Лямбда)

## Как отсортировать список строк с помощью лямбда-выражения?
```java
public static List<String> sort(List<String> list){
    Collections.sort(list, (a, b) -> a.compareTo(b));
    return list;
}
```

[к оглавлению](#Stream-API-и-Лямбда)

## Что такое «ссылка на метод»? Какие виды ссылок на методы вы знаете?
Если существующий в классе метод уже делает все, что необходимо, то можно воспользоваться механизмом __method reference (ссылка на метод)__ для непосредственной передачи этого метода. Такая ссылка передается в виде:

+ `ContainingClass::staticMethodName` - Ссылка на статический метод;
+ `containingObject::instanceMethodName` - Ссылка на нестатический метод конкретного объекта;
+ `ContainingType::methodName` - Ссылка на нестатический метод любого объекта конкретного типа;
+ `ClassName::new` - Ссылка на конструктор;

Результат будет в точности таким же, как в случае определения лямбда-выражения, которое вызывает этот метод.

```java
private interface Measurable {
    public int length(String string);
}

public static void main(String[] args) {
    Measurable a = String::length;
    System.out.println(a.length("abc"));
}
```

Ссылки на методы потенциально более эффективны, чем использование лямбда-выражений. Кроме того, они предоставляют компилятору более качественную информацию о типе и при возможности выбора между использованием ссылки на существующий метод и использованием лямбда-выражения, следует всегда предпочитать использование ссылки на метод.

[к оглавлению](#Stream-API-и-Лямбда)


## Объясните выражение `System.out::println`.
Данное выражение иллюстрирует механизм _instance method reference_: передачи ссылки на метод `println()` статического поля `out` класса `System`.

[к оглавлению](#Stream-API-и-Лямбда)




## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ
#### [Шпаргалка Java программиста 4. Java Stream API-->]( https://habr.com/ru/company/luxoft/blog/270383/ )
#### [Stream API: универсальная промежуточная операция-->]( https://habr.com/ru/post/262139/ )
#### [Stream API-->]( https://javarush.ru/groups/posts/2203-stream-api )
#### [Полное руководство по Java 8 Stream API в картинках и примерах-->]( https://annimon.com/article/2778 )
#### [Полное руководство по Java Stream API-->]( https://hr-vector.com/java/stream-api )
#### [Введение в Stream API-->]( https://metanit.com/java/tutorial/10.1.php )
#### [Interface Stream<T>-->]( https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html )
#### [Stream API и лямбда выражения в Java.-->]( https://java-master.com/stream-and-lambda-in-java/ )
#### [Использование generic wildcards для повышения удобства Java API-->]( https://habr.com/ru/post/207360/ )
#### [Название-->]( Ссылка )
#### [Название-->]( Ссылка )
#### [Название-->]( Ссылка )

[к оглавлению](#Stream-API-и-Лямбда)
